.. index:: ! operator

אופרטורים
=========

ניתן להחיל אופרטורים אריתמטיים ועל ביטים גם אם לשני האופרנדים אין אותו סוג.
לדוגמה, אתם יכולים לחשב ``y = x + z``, כאשר ``x`` הוא ``uint8`` ו-``z`` הוא ``uint32``. במקרים אלה, המנגנון הבא ישמש כדי לקבוע את
הסוג שבו מחושבת הפעולה (חשוב במקרה של הצפה)
וסוג התוצאה של המפעיל:

1. אם ניתן להמיר באופן מרומז את סוג האופרנד הימני לסוג השמאלי,
   השתמש בסוג האופרנד השמאלי,
2. אם ניתן להמיר באופן מרומז את סוג האופרנד השמאלי לסוג הימני,
   השתמש בסוג האופרנד הנכון,
3. אחרת, הפעולה אסורה.

במקרה שאחד מהאופרנדים הוא :ref:`מספר ליטרלי<rational_literals>` הוא מומר תחילה למספר שלו "סוג mobile", שהוא הסוג הקטן ביותר שיכול להחזיק את הערך
(טיפוסים לא חתומים באותו רוחב ביטים נחשבים "קטנים" יותר מהסוגים החתומים).
אם שניהם מספרים ליטרליים, הפעולה מחושבת בדיוק בלתי מוגבל למעשה,
כך שהביטוי מוערך לכל דיוק נדרש כדי שכלום  לא יאבד
כאשר משתמשים בתוצאה עם סוג לא ליטרלי.

סוג התוצאה של המפעיל זהה לסוג שבו מתבצעת הפעולה,
למעט אופרטורי השוואה שבהם התוצאה היא תמיד ``bool``.

האופרטורים ``**`` (העלאה בחזקה), ``<<`` ו-``>>`` משתמשים בסוג של
האופרנד השמאלי לפעולה ולתוצאה.

אופרטור טרנרי
----------------
האופרטור הטרנרי ("משולש") משמש בביטויים מהצורה
``<expression> ? <trueExpression> : <falseExpression>``.
והוא מעריך את אחד משני הביטויים האחרונים בהתאם לתוצאת
ההערכה של ה-``<ביטוי>`` הראשי.
אם ``<ביטוי>`` מוערך ל-``true``, אז ``<trueExpression>`` יוערך, אחרת ה-``<falseExpression>`` יוערך.

לתוצאה של האופרטור השלישי אין סוג מספר רציונלי, גם אם כל האופרנדים שלו הם
ליטרלים של מספר רציונלי.
סוג התוצאה נקבע על-פי הסוגים של שני האופרנדים באותו אופן כמו לעיל, המרה
לסוג הmobile שלהם תחילה במידת הצורך.

כתוצאה מכך, ``255 + (true ? 1 : 0)`` יחזור עקב הצפה אריתמטית.
הסיבה היא ש-``(true ? 1 : 0)`` הוא מסוג ``uint8``, מה שמאלץ
את התוספת להתבצע גם ב-``uint8``, ו-256 חורג מהטווח המותר לסוג זה.

תוצאה נוספת היא שביטוי כמו ``1.5 + 1.5`` תקף אך ``1.5 + (true ? 1.5 : 2.5)`` לא.
הסיבה לכך היא שהביטוי הראשון הוא ביטוי רציונלי המוערך בדייקנות בלתי מוגבלת
ורק ערכו הסופי חשוב.
הביטוי האחרון כרוך בהמרה של שבר הניתן כמספר רציונלי למספר שלם, מה שאסור כרגע.

.. index:: assignment, lvalue, ! compound operators

אופרטורים מורכבים ואופרטורים של הגדלה\\הפחתה
------------------------------------------

אם ``a`` הוא LValue (כלומר משתנה או משהו שניתן להקצות אליו),
האופרטורים הבאים זמינים כקיצורים:

``a += e`` שווה ערך ל-``a = a + e``. האופרטורים ``=-``, ``=*``, ``=/``, ``=%``,
``=|``, ``=&``, ``=^``, ``=<<`` ו-``=>>`` מוגדרים בהתאם. ``++a`` ו-``--a`` שווי ערך
ל- ``a += 1`` / ``a -= 1`` אבל לביטוי עצמו עדיין יש את הערך הקודם של ``a``.
לעומת זאת, ל-``a--`` ו-``a++`` יש את אותה השפעה על ``a`` אבל
היא מחזירה את הערך לאחר השינוי.

.. index:: !delete

.. _delete:

מחיקה (delete)
------

``delete a`` מקצה את הערך ההתחלתי של סוג המשתנה ל-``a``. כְּלוֹמַר. עבור מספרים 
הפעולה שוות ערך ל-``a = 0``, אך ניתן להשתמש בו גם במערכים, שבהם הוא מקצה דינאמית
מערך באורך אפס או מערך סטטי באותו אורך כאשר לכל האלמנטים מוגדר
הערך ההתחלתי של הסוג. ``delete a[x]`` מוחק את האיבר באינדקס ``x`` של המערך
ומשאיר את כל שאר האיברים ואורך המערך ללא שינוי. במיוחד, הוא משאיר
פער במערך. אם אתם מתכננים להסיר איברים, :ref:`mapping <mapping-types>` הוא
כנראה בחירה טובה יותר.

עבור strucs, הוא מקצה struct עם איפוס כל האיברים. במילים אחרות,
הערך של ``a`` לאחר ``delete a`` זהה כאילו ``a`` יוגדר
ללא הקצאה, עם ההסתייגות הבאה:

ל-``delete`` אין השפעה על מיפויים (מכיוון שהמפתחות של המיפויים עשויים להיות שרירותיים
ובדרך כלל לא ידועים). לכן, אם תמחק struct, כל האיברים
שאינם מיפויים וגם recurse לאיברים אלא אם כן הם מיפויים, יאפסו.
עם זאת, ניתן למחוק מפתחות בודדים ולמה שהם ממופים: אם ``a`` הוא
מיפוי, אז ``delete a[x]`` תמחק את הערך המאוחסן ב-``x``.

חשוב לציין ש-``delete a`` מתנהג כמו
הקצאה ל-``a``, כלומר היא מאחסנת אובייקט חדש ב-``a``.
הבחנה זו גלויה כאשר ``a`` הוא משתנה הפניה:
הפעולה תאפס רק את ``a`` עצמו, לא את
הערך שאליו הפנה בעבר.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.0 <0.9.0;

    contract DeleteExample {
        uint data;
        uint[] dataArray;

        function f() public {
            uint x = data;
            delete x; // sets x to 0, does not affect data
            delete data; // sets data to 0, does not affect x
            uint[] storage y = dataArray;
            delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also
            // y is affected which is an alias to the storage object
            // On the other hand: "delete y" is not valid, as assignments to local variables
            // referencing storage objects can only be made from existing storage objects.
            assert(y.length == 0);
        }
    }

.. index:: ! operator; precedence
.. _order:

סדר עדיפות של מפעילים
--------------------------------

.. include:: types/operator-precedence-table.rst
