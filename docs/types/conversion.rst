.. index:: ! type;conversion, ! cast

.. _types-conversion-elementary-types:

המרות בין סוגי משתנים יסודיים
====================================

המרות פנימיות
--------------------

המרה פנימית בין סוגי משתנים נעשית באופן אוטומטי על ידי הקומפיילר בחלק מהמקרים
במהלך הקצאת המשתנים, בעת העברת ארגומנטים לפונקציות ובעת הפעלת אופרטורים.
באופן כללי, המרה פנימית בין סוגי משתנים אפשרית אם היא מבוצעת
באופן הגיוני מבחינה סמנטית ושום מידע לא אובד.

לדוגמה, ``uint8`` ניתן להמרה
ל-``uint16`` ו-``int128`` ל-``int256``, אבל ``int8`` אינו ניתן להמרה ל-``uint256``,
כי ``uint256`` אינו יכול להחזיק ערכים כגון ``1-``.

אם אופרטור מיושם על סוגים שונים, הקומפיילר מנסה להמיר באופן פנימי
את אחד מהאופרנדים לסוג השני (הדבר נכון לגבי השמות - assignments).
המשמעות היא שפעולות תמיד מבוצעות על-פי הסוג של אחד האופרנדים.

לפרטים נוספים על אילו המרות פנימיות אפשריות,
ראו בסעיפים על הסוגים עצמם.

בדוגמה למטה, ל-``y`` ו-``z``, האופרנדים של החיבור,
אין אותו סוג, אבל אפשר להמיר ``uint8``
באופן פנימי ל-``uint16`` אבל לא להיפך. זאת מכיוון
ש-``y`` מומר לסוג ``uint16`` של ``z`` לפני ביצוע החיבור.
הסוג של הביטוי ``y + z`` הוא ``uint16``.
מכיוון שהוא מוצב במשתנה מסוג ``uint32`` המרה פנימית נוספת
מבוצעת לאחר החיבור.

.. code-block:: solidity

    uint8 y;
    uint16 z;
    uint32 x = y + z;


המרות חיצוניות
--------------------

אם הקומפיילר אינו מאפשר המרה פנימית אבל אתם בטוחים שהמרה תעבוד,
המרת סוג מפורשת אפשרית לפעמים. המרה כזו יכולה
לגרום להתנהגות בלתי צפויה ומאפשרת לכם לעקוף חלק ממנגנוני האבטחה
של הקומפיילר. לכן צריך להקפיד לבדוק את
התוצאה ולוודא שהיא התוצאה הפוייה!

ראו למשל את הדוגמה הבאה הממירה ``int`` שלילי ל-``uint``:

.. code-block:: solidity

    int  y = -3;
    uint x = uint(y);

בסוף קטע קוד זה, ``x`` יהיה בעל הערך ``0xfffff..fd`` (64 תווים הקסדצימליים), שהוא 3- בייצוג  משלים ל-2 של 256 ביטים.

אם מספר שלם מומר במפורש לסוג קטן יותר, ביטים מסדר גבוה יותר יחתכו:

.. code-block:: solidity

    uint32 a = 0x12345678;
    uint16 b = uint16(a); // b will be 0x5678 now

אם מספר שלם מומר במפורש לסוג גדול יותר, הוא מרופד בצד שמאל (כלומר, בצד הסדר הגבוה יותר).
תוצאת ההמרה תהיה שווה למספר השלם המקורי:

.. code-block:: solidity

    uint16 a = 0x1234;
    uint32 b = uint32(a); // b will be 0x00001234 now
    assert(a == b);

משתנים בגודל קבוע מסוג בתים (bytes) מתנהגים בצורה שונה במהלך ההמרות. אפשר
לחשוב עליהם כעל רצפים של בתים בודדים והמרה לסוג קטן יותר תנתק את הרצף:

.. code-block:: solidity

    bytes2 a = 0x1234;
    bytes1 b = bytes1(a); // b will be 0x12

אם סוג בתים בגודל קבוע מומר במפורש לסוג גדול יותר, הוא מרופד
מימין. גישה לבית באינדקס קבוע תגרום לאותו ערך לפני
ואחרי ההמרה (אם האינדקס עדיין בטווח):

.. code-block:: solidity

    bytes2 a = 0x1234;
    bytes4 b = bytes4(a); // b will be 0x12340000
    assert(a[0] == b[0]);
    assert(a[1] == b[1]);

מכיוון שמספרים שלמים ומערכי בתים בגודל קבוע מתנהגים אחרת בעת חיתוך או
ריפוד, המרות מפורשות בין מספרים שלמים ומערכי בתים בגודל קבוע מותרות רק
אם שניהם באותו גודל. אם אתם רוצים להמיר בין מספרים שלמים למערכי בתים בגודל קבוע
בגדלים שונים, עליכם להשתמש בהמרות ביניים שיבצעו את כללי החיתוך והריפוד הרצויים
באופן מפורש:

.. code-block:: solidity

    bytes2 a = 0x1234;
    uint32 b = uint16(a); // b will be 0x00001234
    uint32 c = uint32(bytes4(a)); // c will be 0x12340000
    uint8 d = uint8(uint16(a)); // d will be 0x34
    uint8 e = uint8(bytes1(a)); // e will be 0x12

ניתן להמיר באופן מפורש מערכי ``bytes`` ו-calldata slices ``bytes`` לסוגי בתים קבועים (``bytes1``/.../``bytes32``).
במקרה שהמערך ארוך יותר מסוג הבתים הקבועים הארוך ביותר של היעד, הקטיעה בסוף תתבצעה.
אם המערך קצר יותר מסוג היעד, הוא ירופד באפסים בסוף.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.5;

    contract C {
        bytes s = "abcdefgh";
        function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
            require(c.length == 16, "");
            bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen
            b = bytes16(s);  // padded on the right, so result is "abcdefgh\0\0\0\0\0\0\0\0"
            bytes3 b1 = bytes3(s); // truncated, b1 equals to "abc"
            b = bytes16(c[:8]);  // also padded with zeros
            return (b, b1);
        }
    }

.. index:: ! literal;conversion, literal;rational, literal;hexadecimal number
.. _types-conversion-literals:

המרות בין ליטרלים לסוגים יסודיים
====================================

סוגי מספרים שלמים
--------------------

ניתן להמיר ליטרלים של מספרים עשרוניים והקסדצימליים באופן פנימי לכל סוג מספר שלם
שגדול מספיק כדי לייצג את המספר ללא חיתוך:

.. code-block:: solidity

    uint8 a = 12; // fine
    uint32 b = 1234; // fine
    uint16 c = 0x123456; // fails, since it would have to truncate to 0x3456

.. note::
   לפני גרסה 0.8.0, המרה של כל המספרים הליטרליים העשרוניים או הקסדצימליים
   יכלה להתבצע באופן מפורש לסוג מספר שלם. מגרסה 0.8.0, המרות חיצונית
   כאלו הן מחמירות כמו המרות פנימית.
   כלומר, הן מותרות רק אם הליטרל מתאים לטווח המתקבל.

.. index:: literal;string, literal;hexadecimal

מערכי בתים בגודל קבוע
----------------------

לא ניתן להמיר ליטרלים של מספר עשרוני באופן פנימי למערכי בתים בגודל קבוע.
ליטרל של מספרים הקסדצימליים ניתן להמיר באופן פנימי למערכי בתים בגודל קבוע,
אבל רק אם מספר הספרות ההקסדצימליות מתאים בדיוק לגודל מערך הבתים.
יוצאים מן הכלל הם ליטרלים עשרוניים ו-הקסדצימליים בעלי ערך אפס -
אפשר להמיר ליטרלים אלו לכל סוג בתים בגודל קבוע:

.. code-block:: solidity

    bytes2 a = 54321; // not allowed
    bytes2 b = 0x12; // not allowed
    bytes2 c = 0x123; // not allowed
    bytes2 d = 0x1234; // fine
    bytes2 e = 0x0012; // fine
    bytes4 f = 0; // fine
    bytes4 g = 0x0; // fine

מחרוזות-ליטרלים ומחרוזות של מספרים הקסדצימליים
ניתן להמיר למערכי בתים בגודל קבוע,
אם מספר התווים שלהן תואם לגודל סוג הבתים:

.. code-block:: solidity

    bytes2 a = hex"1234"; // fine
    bytes2 b = "xy"; // fine
    bytes2 c = hex"12"; // not allowed
    bytes2 d = hex"123"; // not allowed
    bytes2 e = "x"; // not allowed
    bytes2 f = "xyz"; // not allowed

.. index:: literal;address

כתובות
---------

כפי שמתואר ב-:ref:`address_literals`, ליטרלים הקסדצימליים
בגודל הנכון שעוברים את בדיקת ה-checksum
הם מסוג ``address``. לא ניתן להמיר ליטרלים אחרים באופן פנימי לסוג ``address``.

המרות מפורשות ל-``address`` מותרות רק מ-``bytes20`` ו-``uint160``.

ניתן להמיר ``address a`` במפורש ל-``address payable`` באמצעות ``payable(a)``.

.. note::
   לפני גרסה 0.8.0, ניתן היה להמיר במפורש מכל סוג מספר שלם (בכל גודל, חתום או לא חתום) ל``address`` או ``address payable``.
   החל מ-0.8.0 מותרת רק המרה מ-``uint160``.