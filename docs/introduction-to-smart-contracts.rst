###############################
מבוא לחוזים חכמים
###############################

.. _simple-smart-contract:

***********************
חוזה חכם פשוט
***********************

נתחיל בדוגמה בסיסית שקובעת את הערך של משתנה וחושפת
אותו לגישה לחוזים אחרים. אל תדאגו אם אתם לא מבינים
הכל עכשיו, ניכנס לפרטים נוספים מאוחר יותר.

דוגמה לאחסון
===============

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.16 <0.9.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public view returns (uint) {
            return storedData;
        }
    }

השורה הראשונה מציינת שקוד המקור מורשה תחת GPL גרסה 3.0. מפרטי רישיונות קריאים  ע"י מכונה חשובים בהגדרה שבה פרסום קוד המקור הוא ברירת המחדל.

השורה הבאה מציינת שקוד המקור נכתב עבור גרסת סולידיטי 0.4.16, או גרסה חדשה יותר של השפה עד, אך לא כולל, גרסה 0.9.0. זאת כדי להבטיח שהחוזה אינו ניתן לקומפילציה עם גרסת קומפיילר חדשה שבה היא יכולה להתנהג אחרת. :ref:`Pragmas<pragma>` הן הנחיות נפוצות עבור קומפיילרים לגבי אופן הטיפול בקוד מקור (למשל `pragma once <https://en.wikipedia.org/wiki/Pragma_once>`_).

חוזה במובן של סולידיטי הוא אוסף של קוד (ה-*פונקציות* שלו) ונתונים (ה-*מצב* שלו) שנמצאים בכתובת ספציפית בבלוקצ'יין של איתריום. השורה ``;uint storedData`` מגדירה משתנה מצב בשם ``storedData`` מסוג ``uint`` ( *u*\nsigned *int*\eger של *256* ביטים). אפשר לחשוב על המשתנה כעל מקטע (Slot) בודד במסד נתונים שאפשר לבצע בו שאילתות ולשנות אותו על ידי קריאה לפונקציות של קוד שמנהל את מסד הנתונים. בדוגמה זו, החוזה מגדיר את הפונקציות ``set`` ו-``get`` שניתן להשתמש בהן כדי לשנות או לקרוא את הערך של המשתנה.

כדי לגשת לחבר (כמו משתנה מצב) מהחוזה הנוכחי,
בדרך כלל לא מוסיפים את הקידומת ``this.``,
פשוט ניגשים אליו ישירות דרך השם שלו.
שלא כמו בשפות אחרות, ההשמטה היא לא רק עניין של סגנון,
אלא גישה אחרת לגמרי לחבר, אבל עוד על הנושא בהמשך.

החוזה הזה לא עושה הרבה עדיין מלבד (בשל התשתית שנבנתה על ידי איתריום)
מתן אפשרות לכל אחד לאחסן מספר בודד הנגיש לכל אחד בעולם ללא דרך (אפשרית)  למנוע פרסום של המספר. כל אחד יכול לקרוא ל-``set`` שוב עם ערך אחר ולהחליף את המספר, אבל המספר עדיין מאוחסן בהיסטוריה של הבלוקצ'יין.
יותר מאוחר, יוסבר כיצד תוכלו להטיל הגבלות גישה כך שרק אתם תוכלו לשנות את המספר.

.. warning::
    היזהרו בשימוש בטקסט יוניקוד, כי תווים עם מראה דומה (או אפילו זהה)
    יכולים להיות מקודדים כמערך בתים שונה.

.. note::
    כל המזהים (שמות חוזים, שמות פונקציות ושמות משתנים)
    מוגבלים לקבוצת התווים ASCII. אפשר לאחסן נתונים המקודדים כ- UTF-8
    במשתני מחרוזת.

.. index:: ! subcurrency

דוגמה לתת-מטבע (Subcurrency)
=============================

החוזה הבא מיישם את הצורה הפשוטה ביותר של מטבע מוצפן.
החוזה מאפשר רק ליוצרו ליצור מטבעות חדשים (אפשריות תוכניות הנפקה שונות).
כל אחד יכול לשלוח מטבעות אחד לשני ללא צורך
להרשם עם שם משתמש וסיסמה. כל מה שצריך הוא צמד מפתחות של איתריום.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.4;

    contract Coin {
        // The keyword "public" makes variables
        // accessible from other contracts
        address public minter;
        mapping(address => uint) public balances;

        // Events allow clients to react to specific
        // contract changes you declare
        event Sent(address from, address to, uint amount);

        // Constructor code is only run when the contract
        // is created
        constructor() {
            minter = msg.sender;
        }

        // Sends an amount of newly created coins to an address
        // Can only be called by the contract creator
        function mint(address receiver, uint amount) public {
            require(msg.sender == minter);
            balances[receiver] += amount;
        }

        // Errors allow you to provide information about
        // why an operation failed. They are returned
        // to the caller of the function.
        error InsufficientBalance(uint requested, uint available);

        // Sends an amount of existing coins
        // from any caller to an address
        function send(address receiver, uint amount) public {
            if (amount > balances[msg.sender])
                revert InsufficientBalance({
                    requested: amount,
                    available: balances[msg.sender]
                });

            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            emit Sent(msg.sender, receiver, amount);
        }
    }

חוזה זה מציג כמה מושגים חדשים, הבה נעבור עליהם אחד אחד.

השורה ``;address public minter`` מצהירה על משתנה מצב מסוג :ref:`address<address>`.
סוג ``address`` הוא ערך של 160 ביטים שאינו מאפשר פעולות אריתמטיות כלשהן.
דבר זה מתאים לאחסון כתובות של חוזים, או hash של החצי הציבורי
של צמד מפתחות השייך ל-:ref:`חשבונות חיצוניים<accounts>`.

מילת המפתח ``public`` מייצרת אוטומטית פונקציה המאפשרת גישה לערך הנוכחי של
משתנה המצב מחוץ לחוזה. ללא מילת מפתח זו, לחוזים אחרים אין דרך לגשת למשתנה.
הקוד של הפונקציה שנוצרת על ידי הקומפיילר הוא שווה ערך לקטע הקוד הבא 
(בינתיים, התעלמו מ-``external`` ו-``view``):

.. code-block:: solidity

    function minter() external view returns (address) { return minter; }

אפשר להוסיף פונקציה כמו הפונקציה למעלה, אבל אז יהיו פונקציה ומשתנה מצב עם אותו שם.
אין צורך לעשות זאת, הקומפיילר מזהה את המצב.

.. index:: mapping

השורה ``;mapping(address => uint) public balances``
מייצרת גם משתנה מצב ציבורי, אבל מטיפוס נתונים מורכב יותר.
הטיפוס :ref:`mapping <mapping-types>` ממפה כתובות ל-:ref:`unsigned integers <integers>`.

ניתן לראות מיפויים בתור `טבלאות hash <https://en.wikipedia.org/wiki/Hash_table>`_
שלמעשה מאותחלות כך שכל מפתח אפשרי קיים מההתחלה וממופה
לערך שבו כל הביטים מאופסים. עם זאת, לא ניתן לקבל רשימה של כל מפתחות המיפוי, ולא רשימה של כל הערכים. צריך לרשום את מה
שנוסף למיפוי, או להשתמש בו באופן כזה שבו אין צורך בכך. או
אפילו טוב יותר, שימרו רשימה, או השתמשו בסוג נתונים מתאים יותר.

ה- :ref:`getter פונקצית<getter-functions>` שנוצרה על ידי מילת המפתח ``public``
מורכבת יותר במקרה של מיפוי. הפונקציה נראית כמו הקוד הבא:

.. code-block:: solidity

    function balances(address account) external view returns (uint) {
        return balances[account];
    }

אתם יכולים להשתמש בפונקציה זו כדי לברר מה היתרה של חשבון בודד.

.. index:: event

אירוע :ref:`"event" <events>` נפלט בשורה האחרונה של הפונקציה
``send``. לקוחות איתריום כגון יישומי אינטרנט יכולים
להקשיב לאירועים הללו הנפלטים בבלוקצ'יין בלי הרבה
עלות. ברגע שהאירוע נפלט, המאזין מקבל את
הארגומנטים ``from``, ``to`` ו-``amount``, המאפשרים מעקב
אחרי טרנזקציות.

כדי להאזין לאירוע, אפשר להשתמש בקטע
קוד JavaScript הבא, המשתמש ב-`web3.js <https://github.com/web3/web3.js/>`_ כדי ליצור את האובייקט של החוזה ``Coin``,
וכל ממשק משתמש קורא לפונקציית ``balances`` שנוצרה אוטומטית מהקוד למעלה:

.. code-block:: javascript

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

.. index:: coin

ה-:ref:`constructor<constructor>` היא פונקציה מיוחדת שמתבצעת במהלך יצירת החוזה ולא ניתן לקרוא לה לאחר מכן. במקרה זה, היא מאחסנת לצמיתות את הכתובת של האדם שיוצר את
החוזה. המשתנה ``msg`` (יחד עם ``tx`` ו-``block``) הוא
:ref:`משתנה גלובלי מיוחד <special-variables-functions>` כי הוא
מכיל מאפיינים המאפשרים גישה לבלוקצ'יין. ``msg.sender`` היא
תמיד הכתובת שממנה הגיעה קריאת הפונקציה הנוכחית (החיצונית).

הפונקציות המרכיבות את החוזה, ושמשתמשים וחוזים יכולים לקרוא להן הן ``mint`` ו``send``.

הפונקציה ``mint`` שולחת כמות של מטבעות שזה עתה נוצרו לכתובת אחרת. קריאת לפונקציה :ref:`require<assert-and-require>` מגדירה תנאים שבמידה ולא כולם מתקיימים, כל השינויים שנעשו מוחזרים לאחור ומתבטלים. בדוגמה הזאת, ``;require(msg.sender == minter)`` מבטיח שרק יוצר החוזה יכול לקרוא ל-``mint``. באופן כללי, אין מגבלה על כמות האסימונים שאפשר לייצר, אבל בשלב מסוים יצירת האסימונים תוביל לתופעה הנקראת "הצפה". שימו לב שבגלל ברירת המחדל :ref:`Checked arithmetic<unchecked>`, הטרנזקציה תתבטל אם הביטוי ``;balances[receiver] += amount`` יגלוש, כלומר, כאשר ``balances[receiver] + amount`` בחישוב אריתמטי עם דיוק שרירותי גדול יותר מהערך המקסימלי של ``uint`` (``2**256 - 1``). דבר זה נכון גם להצהרה ``;balances[receiver] += amount`` בפונקציה ``send``.

:ref:`שגיאות <errors>` מאפשרות לספק מידע נוסף לקורא לפונקציה לגבי מדוע תנאי או פעולה נכשלו. שגיאות מגיעות יחד עם :ref:`revert statement <revert-statement>`. הצהרת ``revert`` מחזירה לאחור ומבטלת ללא תנאי את כל השינויים, בדומה לפונקציית ``revert``, אך גם מאפשרת לספק את שם השגיאה ונתונים נוספים שיסופקו לקורא לפונקציה (ובסופו של דבר לאפליקציית ה-front-end או ה-block explorer) כך שבמקרה של כשל יהיה אפשר לנפות באגים או להגיב עליהם בקלות רבה יותר.

הפונקציה ``send`` יכולה לשמש כל אחד (שכבר יש להם כמה מהמטבעות האלה) כדי לשלוח מטבעות לכל אחד אחר. אם אין לשולחים מספיק מטבעות לשלוח, התנאי ``if`` נחשב כאמת. כתוצאה מכך, ה-``revert`` יגרום לפעולה להיכשל תוך מתן פרטי שגיאה לשולח באמצעות השגיאה ``InsufficientBalance``.

.. note:: 
    אם אתם משתמשים בחוזה הזה כדי לשלוח מטבעות לכתובת, לא תראו כלום כאשר תסתכלו על הכתובת הזו ב-blockchain Explorer, בגלל שהרשומה שבה שלחתם מטבעות והיתרות שהשתנו מאוחסנים רק באחסון הנתונים של חוזה המטבע המסוים הזה. על ידי שימוש באירועים, אתם יכולים ליצור "blockchain Explorer" שעוקב אחר טרנזקציות ויתרות של המטבע החדש שלכם, אבל אתם צריכים לבדוק את כתובת חוזה המטבע ולא את הכתובות של בעלי המטבעות.

.. _blockchain-basics:

******************
יסודות הבלוקצ'יין
******************

בלוקצ'יין בתור מושג לא קשה מדי להבנה על ידי מתכנתים. הסיבה היא שרוב הסיבוכים (כרייה, `hashing <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_,
`elliptic-curve cryptography <https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>`_,
`peer-to-peer networks <https://en.wikipedia.org/wiki/Peer-to-peer>`_, וכו') הם שם רק כדי לספק קבוצה מסוימת של תכונות והבטחות לפלטפורמה. ברגע שאתם מקבלים את התכונות האלה כפי שהוגדרו, אין צורך לדאוג לגבי הטכנולוגיה הבסיסית - כמו שאתם לא צריכים לדעת איך ה-AWS של אמזון פועל באופן פנימי כדי להשתמש בו.

.. index:: transaction

טרנזקציות
===========

בלוקצ'יין הוא מסד נתוני עסקאות משותף גלובלי.
המשמעות היא שכל אחד יכול לקרוא ערכים במסד הנתונים רק על ידי השתתפות ברשת.
כדי לשנות משהו במסד הנתונים, צריך ליצור מה שנקרא טרנזקציה
שצריכה להתקבל על ידי כל האחרים.
המילה טרנזקציה מרמזת על כך שהשינוי שאותו רוצים לעשות (נניח שינוי
שני ערכים בו-זמנית) - או שהוא לא נעשה כלל או שהוא מיושם לחלוטין. יתר על כן,
בזמן שהטרנזקציה מוחלת על מסד הנתונים, שום טרנזקציה אחרת לא יכולה לשנות אותו.

כדוגמה, דמיינו טבלה המפרטת את היתרות של כל החשבונות של
מטבע אלקטרוני מסויים. אם יש בקשה להעברה מחשבון אחד לאחר,
אופי הטרנזקציות של מסד הנתונים מבטיח שאם הסכום מופחת מחשבון אחד, הוא תמיד יתווסף לחשבון השני. אם בשל
סיבה כלשהיא, הוספת הסכום לחשבון היעד אינה אפשרית,
גם חשבון המקור לא ישונה.

בנוסף לכך, טרנזקציה נחתמת תמיד בחתימה קריפטוגרפית על ידי השולח (היוצר).
דבר זה מאפשר לפשט את ההגנה על גישה לשינויים ספציפיים של
מאגר המידע. בדוגמה של המטבע האלקטרוני, בדיקה פשוטה מבטיחה שרק האדם המחזיק במפתחות לחשבון יכול להעביר תשלום כלשהו, למשל איתר, ממנו.

.. index:: ! block

בלוקים
=======

מכשול מרכזי אחד שצריך להתגבר עליו הוא מה שמכונה (במונחי ביטקוין) "התקפת הוצאה-כפולה" ("double-spend attack"): מה קורה אם קיימות שתי טרנזקציות ברשת ששתיהן רוצות לרוקן חשבון? רק אחת מהטרנזקציות יכולה להיות תקפה, בדרך כלל זו שמתקבלת ראשונה. הבעיה היא ש-"ראשון" אינו מונח אובייקטיבי ברשת עמית לעמית.

התשובה המופשטת לכך היא שאין לסדר חשיבות. סדר טרנזקציות מקובל גלובלית ייבחר ע"י המערכת ויפתור את ההתנגשות. הטרנזקציות יקובצו במה שנקרא "בלוק" ואז הן יבוצעו ויופצו בין כל הצמתים (Nodes) המשתתפים. אם שתי טרנזקציות סותרות זו את זו, זו שבסופו של דבר השנייה תידחה ולא תהפוך לחלק מהבלוק.

בלוקים אלו יוצרים רצף ליניארי בזמן, ומכאן נובעת המילה "בלוקצ'יין". בלוקים מתווספים לשרשרת במרווחי זמן קבועים, אם כי מרווחים אלה עשויים להשתנות במשך הזמן. לקבלת המידע העדכני ביותר, מומלץ לנטר את הרשת, למשל, ב- `Etherscan <https://etherscan.io/chart/blocktime>`_.

כחלק מ"מנגנון בחירת הסדר" (שנקרא "כרייה") עלול לקרות שהשינויים שבוצעו ע"י בלוקים יוחזרו לאחור ויבוטלו מדי פעם, אבל רק ב"קצה" השרשרת. כמה שיותר בלוקים מתווספים לפני בלוק מסוים, כך פוחת הסיכוי ששינויי בלוק זה יבוטלו. לכן ייתכן שהטרנזקציות שלכם יבוטלו ואולי אפילו יוסרו מהבלוקצ'יין, אך ככל שתחכו יותר כך פחות סביר שזה יקרה.

.. note:: 
    לא מובטח שטרנזקציות ייכללו בבלוק הבא או בכל בלוק עתידי ספציפי, מכיוון שהכורים קובעים באיזה בלוק הטרנזקציה כלולה, ולא שולח הטרנזקציה. אם אתם רוצים לתזמן פעילויות עתידיות בחוזה שלכם, אתם יכולים להשתמש בכלי אוטומציית חוזים חכמים או בשירותי אורקל.

.. _the-ethereum-virtual-machine:

.. index:: !evm, ! ethereum virtual machine

********************************
מכונת איתריום הוירטואלית (EVM)
********************************

סקירה כללית
============

המכונה הורטואלית של איטריום (Ethereum Virtual Machine - EVM) היא סביבת זמן הריצה עבור חוזים חכמים באתריום. היא לא משמשת רק בארגז חול אלא למעשה מבודדת לחלוטין, מה שאומר שלקוד שרץ בתוך ה-EVM אין גישה לרשת, למערכת קבצים או לתהליכים אחרים. לחוזים חכמים יש אפילו גישה מוגבלת לחוזים חכמים אחרים.

.. index:: ! account, address, storage, balance

.. _accounts:

חשבונות
========

ישנם שני סוגים של חשבונות באיתריום שחולקים את אותו
מרחב כתובת: **חשבונות חיצוניים** הנשלטים על ידי
צמדי מפתחות ציבוריים-פרטיים (כלומר בני אדם) ו-**חשבונות חוזה**
שנשלטים על ידי הקוד המאוחסן יחד עם החשבון.

הכתובת של חשבון חיצוני נקבעת מתוך
המפתח הציבורי בזמן שכתובת החוזה
נקבעת במועד יצירת החוזה
(כתובת זו נגזרת מכתובת היוצר ומהמספר
של טרנזקציות שנשלחו מאותה כתובת, מה שנקרא "nonce").

לא משנה אם החשבון מאחסן קוד או לא, שני הסוגים
מטופלים באופן שווה על ידי ה-EVM.

לכל חשבון יש מאגר מפתחות-ערכים (key-value) תמידי (persistent) הממפה מילים של 256 ביטים למילים של 256 ביטים
שנקרא **Storage**.

יתר על כן, לכל חשבון יש **יתרה (balance)** במטבע איתר (ב"Wei" ליתר דיוק, ``איתר 1`` הוא ``10**18 wei``) שניתן לשנות
על ידי שליחת טרנזקציות שכוללות איתר.

.. index:: ! transaction

טרנזקציות
==========

טרנזקציה היא הודעה שנשלחת מחשבון אחד
לחשבון אחר (שעשוי להיות זהה או ריק, ראה להלן).
הטרנזקציה יכולה גם לכלול נתונים בינאריים (שנקראים "payload") ואיתר.

אם חשבון היעד מכיל קוד, קוד זה מבוצע וה-payload מסופק לו כנתוני קלט.

אם חשבון היעד אינו מוגדר (אין לטרנזקציה
נמען או הנמען מוגדר כ-``null``), הטרנזקציה
יוצרת **חוזה חדש**.
כאמור, כתובתו של אותו חוזה אינה
כתובת האפס אלא כתובת הנגזרת מהשולח
וממספר הטרנזקציות שנשלחו (ה-"nonce"). ה-payload
של טרנזקציה כזו שיוצרת חוזה נחשבת
כ-EVM bytecode ומבוצעת. נתוני הפלט של ביצוע זה
מאוחסנים לצמיתות כקוד החוזה.
משתמע מכך שכדי ליצור חוזה לא נשלח
הקוד בפועל של החוזה, אלא למעשה נשלח קוד שמחזיר את קוד זה כאשר הוא מופעל.

.. note:: 
  בזמן יצירת חוזה, הקוד שלו עדיין ריק.
  לכן לא קוראים לחוזה בהקמה עד שהיצירה שלו מסתיימת.


.. index:: ! gas, ! gas price

גז
===

עם היצירה, כל טרנזקציה מחויבת בכמות מסוימת של **גז**
שעליו יש לשלם על ידי יוזם הטרנזקציה(``tx.origin``).
בזמן שה-EVM מבצע את
הטרנזקציה, הגז מתרוקן בהדרגה על פי כללים ספציפיים.
אם הגז מנוצל בשלב כלשהו (כלומר, הכמות הופכת לשלילית),
מופעל טיפול חריג (exception) שלא משתמש בגז, אשר מסיים את הביצוע ומחזיר לאחור את כל השינויים
שבוצעו למצב במסגרת הקריאה הנוכחית לחוזה.

מנגנון זה מעודד שימוש חסכוני בזמן ביצוע EVM
וכן מפצה את מבצעי EVM (כלומר כורים / משקיעים) על עבודתם.
מכיוון שלכל בלוק יש כמות מקסימלית של גז, הוא גם מגביל את כמות
העבודה הדרושה כדי לאמת בלוק.

**מחיר הגז** הוא ערך שנקבע על ידי יזם הטרנזקציה, אשר
צריך לשלם ``מחיר_גז * גז`` מראש למבצע ה-EVM.
אם נותר גז לאחר הביצוע, הוא יוחזר ליזם הטרנזקציה.
במקרה של חריגה שמחזירה לאחור ומבטלת שינויים, גז שכבר נוצל לא יוחזר.

מכיוון שמבצעי EVM יכולים לבחור אם לכלול טרנזקציה בבלוק,
שולחי טרנזקציות אינם יכולים לעשות שימוש לרעה במערכת על ידי קביעת מחיר גז נמוך.

.. index:: ! storage, ! memory, ! stack

סוגי מרחבי אחסון - Storage, Memory ו-Stack
=================================================

ל-EVM יש שלושה אזורים שבהם הוא יכול לאחסן נתונים:
storage, memory ו-stack.

לכל חשבון יש אזור נתונים שנקרא **Storage**, שנשמר בין קריאות לפונקציה
וטרנזקציות.
אחסון הוא מאגר מפתח-ערך שממפה מילים של 256 ביטים למילים של 256 ביטים.
לא ניתן לבצע enumeration ל-storage מתוך חוזה, הוא
יקר יחסית לקריאה, ואפילו יקר יותר לאתחל ולשנות את ה-storage. בגלל העלות הזו,
צריך לצמצם למינימום את מה שמאחסנים ב-storage למה שהחוזה צריך כדי לפעול.
אחסנו ב-storage נתונים כמו תוצאות של חישובים, שמירה במטמון ונתונים מחוץ לחוזה.
חוזה אינו יכול לקרוא או לכתוב ל-storage כלשהו מלבד שלו.

אזור הנתונים השני נקרא **memory**, שמאותחל מחדש עבור כל קריאה לחוזה. ה-memory הוא ליניארי ויכול להיות
מטופל ברמת בתים, אך הקריאות מוגבלות לרוחב של 256 ביטים, כאשר כתיבה
יכולה להתבצע הן ברוחב של 8 ביטים והן ברוחב של 256 ביטים. ה-memory מורחב במילה (256 סיביות), כאשר
ניגשים (קריאה או כתיבה) למילת memory שלא נגעו בה בעבר (כלומר כל היסט
בתוך המילה). בעת ההרחבה יש לשלם את העלות בגז. ה-memory יותר
יקר ככל שהוא גדל (והעלות גדלה באופן ריבועי).

הסוגי מרחבי אחסון - Storage, Memory ו-Stack
-EVM אינו מכונת register אלא מכונת stack, לכן כל
החישובים מבוצעים על אזור נתונים הנקרא **stack**. ל-stack יש גודל מקסימלי של
1024 אלמנטים והוא מכיל מילים של 256 ביטים. הגישה ל-stack
מוגבלת לקצה העליון בצורה הבאה:
אפשר להעתיק את אחד
מ-16 האלמנטים העליונים ביותר לראש
ה-stack או להחליף את
האלמנט העליון עם אחד מ-16 האלמנטים מתחתיו.
כל שאר הפעולות לוקחות את שני האלמנטים העליונים ביותר (אחד או יותר, תלוי
בפעולה) ודוחפות את התוצאה אל ה-stack.
כמובן שאפשר להעביר אלמנטים מה-stack ל-storage או ל-memory
על מנת לקבל גישה עמוקה יותר ל-stack,
אבל לא ניתן לגשת לאלמנטים שרירותיים עמוק יותר ב-stack
מבלי להסיר תחילה את החלק העליון שלו.

.. index:: ! instruction

סט הוראות
==========

סט ההוראות של ה-EVM נשמרת מינימלית על מנת להימנע
מיישומים לא נכונים או לא עקביים שעלולים לגרום לבעיות קונצנזוס בין הצמתים.
כל ההוראות פועלות על סוג הנתונים הבסיסי, מילים של 256 ביטים או על פרוסות זיכרון (או מערכי בתים אחרים).
קיימות הפעולות הרגילות - פעולות החשבון, ביטים, הלוגיות וההשוואה.
קפיצות מותנות ובלתי מותנות אפשריות. יתר על כן,
חוזים יכולים לגשת למאפיינים הרלוונטיים של הבלוק הנוכחי
כמו המספר וחותמת הזמן שלו.

לרשימה מלאה, ראה :ref:`list of opcodes <opcodes>` כחלק מתעוד ה-Assembly.

.. index:: ! message call, function;call

קריאות לחוזה (Message Calls)
=============================

חוזים יכולים להתקשר לחוזים אחרים או לשלוח איתר
לחשבונות שאינם חוזים באמצעות קריאות לחוזים (message calls). קריאות לחוזים דומות
לטרנזקציות בכך שיש להן מקור, יעד, payload,
נתוני איתר, גז ונתונים שמוחזרים לקורא (return data). למעשה, כל טרנזקציה מורכבת 
מקריאה לחוזה ברמה העליונה אשר בתורה יכולה ליצור קריאות נוספות לחוזים.

חוזה יכול להחליט כמה מה**גז** שנותר לו ישלח
עם הקריאה הפנימית לחוזה וכמה הוא רוצה לשמור.
אם מתרחשת חריגה (exception) בגלל שנגמר הגז בקריאה הפנימית לחוזה (או בכל
חריגה אחרת), מצב זה יסומן על ידי ערך שגיאה שהוכנס ל-stack.
במקרה זה, רק הגז שנשלח יחד עם הקריאה לחוזה מנוצל.
בסולידיטי, החוזה הקורא גורם לחריגה ידנית כברירת מחדל
במצבים כאלה, כך שחריגות "מבעבעות" דרך מחסנית הקריאות.

כפי שכבר נאמר, החוזה שנקרא (שיכול להיות זהה לחוזה הקורא)
יקבל memory נקי ויש לו גישה
ל-payload של הקריאה באזור נפרד הנקרא **calldata**.
לאחר סיום הביצוע, החוזה יכול להחזיר נתונים שיישמרו
במיקום ב-memory שהוקצה מראש על ידי החוזה הקורא.
כל הקריאות הללו לחוזים הן סינכרוניות לחלוטין.

קריאות לחוזים **מוגבלות** לעומק 1024, מה שאומר שעבור פעולות
מורכבות יותר, יש להעדיף לולאות על פני קריאות רקורסיביות לחוזים. יתר על כן,
בקריאה לחוזה ניתן להעביר רק עד 63/64 מהגז של החוזה הקורא, מה שגורם
למגבלת עומק של קצת פחות מ-1000 בפועל.

.. index:: delegatecall, library

Delegatecall and Libraries
==========================

קיימת גרסה מיוחדת של קריאה לחוזה, בשם **delegatecall**
שזהה לקריאה לחוזה מלבד העובדה
aהקוד בכתובת היעד מבוצע בהקשר (כלומר בכתובת) של החוזה הקורא
ו-``msg.sender`` ו-``msg.value`` אינם משנים את הערכים שלהם.

המשמעות היא שחוזה יכול לטעון באופן דינמי קוד
מכתובת אחרת בזמן ריצה. storage, כתובת נוכחית ויתרה (balance) עדיין
מתייחסים לחוזה הקורא, רק הקוד נלקח מכתובת החוזה שנקרא.

דבר זה מאפשר ליישם את תכונת "הספרייה" בסולידיטי:
קוד ספרייה לשימוש חוזר שניתן להחיל על ה-storage של חוזה, למשל.
על מנת ליישם מבנה נתונים מורכב.

.. index:: log

לוגים
=====

אפשר לאחסן נתונים במבנה נתונים מיוחד
שממפה את כל הדרך עד לרמת הבלוק. תכונה זו הנקראת **לוגים**
משמשת את סולידיטי כדי ליישם את :ref:`ארועים <events>`.
חוזים אינם יכולים לגשת לנתוני לוג לאחר יצירתם, אבל הם
ניתנים לגישה ביעילות מחוץ לבלוקצ'יין.
מכיוון שחלק מנתוני הלוג מאוחסנים ב`bloom filters <https://en.wikipedia.org/wiki/Bloom_filter>`_,
ניתן לחפש נתונים אלה בצורה יעילה ומוצפנת
בדרך מאובטחת, ולכן עמיתים ברשת שלא מורידים את כל הבלוקצ'יין
(נקראים "לקוחות קלים") עדיין יכולים למצוא את הלוגים האלו.

.. index:: contract creation

יצירת חוזים
============

חוזים יכולים אפילו ליצור חוזים אחרים באמצעות קוד-פעולה מיוחד (כלומר,
הם לא פשוט קוראים לכתובת האפס כפי שטרנזקציה עושה). ההבדל היחיד בין
**קריאה ליצירת חוזה** וקריאות לחוזה רגילות הן שנתוני ה-payload מבוצעים,
התוצאה נשמרת כקוד, והחוזה הקורא
מקבל את כתובת החוזה החדש ב-stack.

.. index:: ! selfdestruct, deactivate

נטרול והשמדה-עצמית
====================

הדרך היחידה להסיר קוד מהבלוקצ'יין היא כאשר החוזה
בכתובת הזו מבצע את פעולת ההשמדה העצמית ``selfdestruct``. האיתר השנותר מאוחסן
בכתובת זו נשלח ליעד ייעודי ולאחר מכן ה-storage והקוד
מוסרים מהמצב. הסרת החוזה בתיאוריה נשמעת כמו
רעיון טוב, אבל זה עלול להיות מסוכן, כי כאשר מישהו שולח איתר לחוזה שלא קיים, האיתר אבוד לנצח.

.. warning::
    מגרסה 0.8.18 ומעלה, השימוש ב-``selfdestruct`` בסולידיטי וגם ב-Yul יפעיל אזהרת הוצאה משימוש (deprication), מכיוון שהאופקוד ``SELFDESTRUCT`` יעבור בסופו של דבר שינויים בהתנהגות כפי שצוין ב-`EIP-6049 <https://eips.ethereum.org/EIPS/eip-6049>`_.

.. warning::
    גם אם חוזה יוסר על ידי ``selfdestruct``, הוא עדיין חלק מההיסטוריה של הבלוקצ'יין וכנראה נשמר על ידי רוב צמתי האיתריום. לכן השימוש ב-``selfdestruct`` אינו זהה למחיקת נתונים מהדיסק הקשיח.

.. note::
    גם אם הקוד של חוזה אינו מכיל קריאה ל-``selfdestruct``, הוא עדיין יכול לבצע את הפעולה הזו באמצעות ``delegatecall`` או ``callcode``.

אם אתם צריכים לנטרל חוזים שלכם, צריך במקום זאת **להשבית** אותם
על ידי שינוי מצב פנימי כלשהו שגורם לכל הפונקציות להחזיר את השינויים למצב הקודם (revert). במצב זה
אין אפשרות להשתמש בחוזה, מכיוון שהוא מחזיר איתר באופן מיידי.


.. index:: ! precompiled contracts, ! precompiles, ! contract;precompiled

.. _precompiledContracts:

חוזים מקומפלים מראש
=====================

יש קבוצה קטנה של כתובות חוזה מיוחדות:
טווח הכתובות בין ``1`` ו-``8`` (כולל) מכיל
"חוזים מקומפלים מראש" שאפשר לקרוא להם כמו כל חוזה אחר
אך התנהגותם (וצריכת הגז שלהם) אינה מוגדרת
כמו קוד EVM המאוחסן בכתובת זו (הם אינם מכילים קוד).
במקום זאת הם מיושמים בסביבת הביצוע של EVM עצמה.

רשתות תואמות EVM שונות עשויות להשתמש בסט שונה של
חוזים שהוכנו מראש. יכול להיות גם
שחוזים חדשים מקומפלים מראש יתווספו לרשת הראשית של איתריום בעתיד,
אבל אתם יכולים להניח שהם תמיד יהיו בטווח הכתובות שבין
``1`` ו-``0xffff`` (כולל).
