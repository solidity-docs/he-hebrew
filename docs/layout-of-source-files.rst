********************************
מבנה קובץ מקור של סולידיטי
********************************

קבצי מקור יכולים להכיל מספר שרירותי של הנחיות
:ref:`contract definitions<contract_structure>`, import_ ,
:ref:`pragma<pragma>` והנחיות :ref:`using for<using-for>` ו-
:ref:`struct<structs>`, :ref:`enum<enums>`, :ref:`function<functions>`, :ref:`error<errors>`
והגדרות :ref:`constant variable<constants>`.

.. index:: ! license, spdx

מזהה רישיון SPDX
=======================

יצירת אמון בחוזים חכמים יכול להתבצע טוב יותר אם קוד המקור שלהם
זמין. מכיוון שהפיכת קוד המקור לזמין נוגעת תמיד לבעיות משפטיות
בכל הנוגע לזכויות יוצרים, הקומפיילר של סולידיטי מעודד את השימוש
`במזהי רישיון SPDX <https://spdx.org>`_ הניתנים לקריאה במכונה.
כל קובץ מקור צריך להתחיל בהערה המציינת את הרישיון שלו:

.. code-block:: solidity

  // SPDX-License-Identifier: MIT

הקומפיילר אינו מאמת שהרישיון הוא חלק מה-
`רשימה מותרת על ידי SPDX <https://spdx.org/licenses/>`_, אבל
הוא כן כולל את המחרוזת שסופקה ב-:ref:`bytecode metadata <metadata>`. 

אם אינכם רוצים לציין רישיון או אם קוד המקור הוא
לא קוד פתוח, אנא השתמשו בערך המיוחד ``UNLICENSED``.
שימו לב ש-``UNLICENSED`` (אסור בשימוש, לא קיים ברשימת הרישיונות של SPDX)
שונה מ-``UNLICENSE`` (מעניק את כל הזכויות לכולם).
Solidity פועלת לפי `המלצת npm <https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license>`_.

הערה זו כמובן אינה משחררת אותכם מחובות אחרים
הקשורות לרישוי, כמו הצורך לציין את
הרישיון הספציפי בכל קובץ מקור או לציין את
בעלי זכויות היוצרים המקוריים.

הקומפיילר מזהה את ההערה בכל מקום בקובץ,
אך מומלץ לשים אותה בראש הקובץ.

מידע נוסף על אופן השימוש במזהי רישיון SPDX
ניתן למצוא `באתר SPDX <https://spdx.org/ids-how>`_.


.. index:: ! pragma

.. _pragma:

Pragmas
=======

מילת המפתח ``pragma`` משמשת להפעלת תכונות קומפיילר או בדיקות
מסוימות. הוראת pragma היא תמיד מקומית לקובץ המקור, לכן
אתם צריכים להוסיף את ה-pragma לכל הקבצים שלכם אם אתם רוצים להפעיל אותה
בכל הפרויקטים שלכם. אם אתם :ref:`מייבאים<import>` קובץ אחר, ה-pragma
מהקובץ הזה *לא* תחול אוטומטית על הקובץ המייבא.

.. index:: ! pragma;version

.. _version_pragma:

גרסת Pragma
--------------

ניתן (וצריך) להוסיף לקבצי מקור pragma שמציינת
עם אילו גרסאות קומפיילר אפשר לקמפל את הקוד,
וזאת כדי למנוע שימוש בגרסאות קומפיילר עתידיות שעלולות להכיל שינויים
שאינם תואמים לקוד. אנחנו מנסים לצמצם את השינוייים הללו למינימום מוחלט
ולהציג אותם באופן כזה ששינויים בסמנטיקה דורשים גם שינויים
בתחביר, אבל זה לא תמיד אפשרי. לכן, זה תמיד
רעיון טוב לקרוא את תאור השינויים לפחות עבור מהדורות המכילות
שינויי התנהגות. גרסאות אלו הן  תמיד בפורמט
``0.x.0`` או ``x.0.0``.

השימוש ב-pragma הוא באופן הבא: ``;pragma solidity ^0.5.2``

קובץ מקור עם השורה למעלה לא יתקמפל עם קומפיילר מוקדם יותר מגרסה 0.5.2,
וגם לא עם קומפיילר עם גרסה החל מ-0.6.0 (זה
התנאי השני שהתווסף באמצעות ``^``). מכיוון
שלא יהיו שינויי התנהגות עד לגרסה ``0.6.0``, אתם יכולים
להיות בטוחים בכך שהקוד שלכם יתקמפל כמו שהתכוונתם. הגרסה המדויקת של
הקומפיילר אינה מצויינת, כך ששחרור תיקוני באגים עדיין אפשרי.

אפשר לציין כללים מורכבים יותר עבור גרסת הקומפיילר.
כללים אלו עוקבים אחר אותו תחביר המשמש את `npm <https://docs.npmjs.com/cli/v6/using-npm/semver>`_.

.. note::
   שימוש ב-pragma הגרסה *לא* משנה את הגרסה של הקומפיילר.
   היא גם *לא* מאפשרת או משביתה תכונות של הקומפיילר. היא רק
   מורה לקומפיילר לבדוק אם הגרסה שלו תואמת את הגרסה
   הנדרש על ידי ה-pragma. אם אין תאימות, הקומפיילר מוציא
   שגיאה.

.. index:: ! ABI coder, ! pragma; abicoder, pragma; ABIEncoderV2
.. _abi_coder:

מקודד ABI Pragma
----------------

באמצעות ``pragma abicoder v1`` או ``pragma abicoder v2`` אתם יכולים
לבחור בין שני המימושים של מקודד ומפענח ABI.

קודן ABI החדש (v2) מסוגל לקודד ולפענח
מערכים ומבנים מקוננים באופן שרירותי. מלבד תמיכה בעוד סוגי משתנים, דבר זה כרוך
בבדיקות אימות ובטיחות נרחבות יותר, שעשויות לגרום לעלויות גז גבוהות יותר, אבל
גם לעלות את רמת הבטחון. דבר זה נחשב
ללא-ניסיוני החל מגרסה 0.6.0 של סולידיטי והוא מופעל כברירת מחדל
החל מגרסת סולידיטי 0.8.0. עדיין ניתן לבחור את קודן ABI הישן באמצעות ``;pragma abicoder v1``.

רשימת סוגי המשתנים הנתמכים על ידי המקודד החדש היא רשימת-על ספציפית של
אלו שנתמכו על ידי המקודד הישן. חוזים המשתמשים ברשימה יכולים ליצור אינטראקציה עם כאלו שלא משתמשים בה בלי מגבלות. ההיפך אפשרי רק כל עוד
החוזה שאינו ``abicoder v2`` אינו מנסה לבצע קריאות שידרשו
סוגי פענוח שנתמכים רק על ידי המקודד החדש. הקומפיילר יכול לזהות זאת
ויוציא שגיאה. מספיק בהפעלת ``abicoder v2`` עבור החוזה שלכם
כדי לגרום לשגיאה להיעלם.

.. note::
   pragma זו חלה על כל הקוד המוגדר בקובץ שבו היא מופעלת,
   ללא קשר לאן הקוד הזה מגיע בסופו של דבר. זאת אומרת שחוזה
   שקובץ המקור שלו נבחר לקומפילציה עם קודן ABI v1
   עדיין יכול להכיל קוד שמשתמש בקודן החדש
   על ידי ירושה מחוזה אחר. דבר זה מותר אם הסוגים החדשים נמצאים רק
   בשימוש פנימי ולא בחתימות של פונקציות חיצוניות.

.. note::
   עד לסולידיטי 0.7.4, ניתן היה לבחור בקודן ABI v2
   על ידי שימוש ב- ``PRagma experimental ABIEncoderV2``, אך אי אפשר היה
   לבחור במפורש בקודן v1 כי זה היה ברירת המחדל.

.. index:: ! pragma; experimental
.. _experimental_pragma:

Experimental Pragma
-------------------

ה-prama השנייה היא ה-prama הניסיונית. ניתן להשתמש בה כדי להפעיל
תכונות של הקומפיילר או של השפה שעדיין לא מופעלות כברירת מחדל.
ה-pragmas הניסיוניות הבאות נתמכות כעת:

.. index:: ! pragma; ABIEncoderV2

ABIEncoderV2
~~~~~~~~~~~~

מכיוון שקודן ABI v2 אינו נחשב ניסיוני יותר,
ניתן לבחור באמצעות ``pragma abicoder v2`` (ראו למעלה)
מאז סולידיטי 0.7.4.

.. index:: ! pragma; SMTChecker
.. _smt_checker:

SMTChecker
~~~~~~~~~~

יש להפעיל רכיב זה כאשר קומפיילר סולידיטי נבנה
ולכן הוא אינו זמין בכל הקבצים הבינאריים של סולידיטי.
הוראת :ref:`build<smt_solvers_build>` מסבירה כיצד להפעיל אפשרות זו.
היא מופעלת עבור מהדורות Ubuntu PPA ברוב הגרסאות,
אבל לא עבור התמונות של Docker, הקבצים הבינאריים של Windows או
הקבצים הבינאריים של לינוקס הבנויים באופן סטטי. ניתן להפעיל
רכיב זה עבור solc-js באמצעות ה-
`smtCallback <https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback>`_ אם יש לכם פותר SMT
שמותקן באופן מקומי ומפעיל solc-js דרך צומת (לא דרך הדפדפן).

אם אתם משתמשים ב-``;pragma experimental SMTCecker``, אתם מקבלים
:ref:`אזהרות בטיחות<formal_verification>` נוספות המתקבלות על ידי שאילתה של
פותר SMT.
הרכיב עדיין לא תומך בכל התכונות של שפת סולידיטיו
וסביר להניח שיוציא אזהרות רבות. במקרה שהוא מדווח על תכונות שאינן נתמכות,
יתכן שהניתוח אינו נכון לחלוטין.

.. index:: source file, ! import, module, source unit

.. _import:

ייבוא קבצי מקור אחרים
============================

תחביר וסמנטיקה
--------------------

סולידיטי תומכת בהצהרות ייבוא כדי לסייע במודולריזציה של הקוד שלכם
בדומה לאלו הזמינים ב-JavaScript
(מ-ES6 ואילך). עם זאת, סולידיטי אינה תומכת במושג של
`ייצוא ברירת מחדל <https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#description>`_.

ברמה גלובלית, אתם יכול להשתמש בהצהרות ייבוא בצורה הבאה:

.. code-block:: solidity

    import "filename";

החלק ``filename`` נקרא *נתיב ייבוא (Impot Path)*.
הצהרה זו מייבאת את כל הסימבוים הגלובליים מ-"filename" (וסמבולים שיובאו לשם) לתוך
התחום הגלובלי נוכחי (שונה מאשר ב-ES6 אך תואם לאחור עבור סולידיטי).
צורה זו אינה מומלצת לשימוש, מכיוון שהיא מזהמת באופן בלתי צפוי את מרחב השמות.
אם תוסיפו פריטים חדשים ברמה העליונה בתוך "filename", הם
מופיעים אוטומטית בכל הקבצים שמייבאים כך מ-"filename". עדיף לייבא
סימבולים ספציפיים במפורש.

הדוגמה הבאה יוצרת סימבול גלובלי חדש ``symbolName`` שכל האיברים שלו הם
הסימבולים הגלובליים מתוך ``"filename"``:

.. code-block:: solidity

    import * as symbolName from "filename";

מה שגורם לכך שכל הסימבולים הגלובליים יהיו זמינים בפורמט ``symbolName.symbol``.

גרסה של תחביר זה, שאינה חלק מ-ES6, אך אולי שימושית, היא:

.. code-block:: solidity

  import "filename" as symbolName;

שהוא שווה ערך ל-``;import * as symbolName from "filename"``.

אם יש התנגשות שמות, ניתן לשנות את שמות הסימבולים בזמן הייבוא. לדוגמה,
הקוד שלהלן יוצר סימבולים גלובליים חדשים ``alias`` ו-``symbol2`` שמתייחסים אליהם
``symbol1`` ו-``symbol2`` מתוך ``"filename"``, בהתאמה.

.. code-block:: solidity

    import {symbol1 as alias, symbol2} from "filename";

.. index:: virtual filesystem, source unit name, import; path, filesystem path, import callback, Remix IDE

נתיבי ייבוא
------------

על מנת להיות מסוגל לתמוך בבנייה המאפשרת ביצוע בכל הפלטפורמות, הקומפיילר
של סולידיטי צריך להגדיר באופן מופשט
את הפרטים של מערכת הקבצים שבה מאוחסנים קבצי המקור.
מסיבה זו נתיבי ייבוא (imports paths) אינם מתייחסים ישירות לקבצים במערכת הקבצים המארחת.
במקום זאת הקומפיילר שומר על מסד נתונים פנימי (*מערכת קבצים וירטואלית (Virtual File System* או *VFS* בקיצור) שבו
לכל יחידת מקור מוקצה *שם יחידת מקור* ייחודי שהוא מזהה לא מובנה.
נתיב הייבוא שצוין בהצהרת import מתורגם לשם יחידת מקור ומשמש אותו
למציאת יחידת המקור המתאימה במסד נתונים זה.

באמצעות ה-:ref:`Standard JSON <compiler-api>` API ניתן לספק ישירות את השמות
ואת התוכן של כל קבצי המקור כחלק מקלט הקומפיילר.
במקרה זה שמות יחידות המקור הם שרירותיים.
עם זאת, אם אתם רוצים שהקומפיילר ימצא ויטען אוטומטית קוד המקור לתוך ה-VFS,
שמות יחידות המקור שלכם צריכים להיות מובנים בצורה שתאפשר התקשרות חוזרת של :ref:`import callback
<import-callback>` כדי לאתר אותם.
בעת שימוש בקומפיילר שורת-פקודה, ברירת המחדל של ה-import callback
תומך בטעינת קוד מקור בלבד
ממערכת הקבצים המארחת, ולכן שמות יחידות המקור שלכם
חייבים להיות נתיבים (paths).
סביבות מסוימות מספקות callbacks מותאמות אישית שהן מגוונות יותר.
לדוגמה `Remix IDE <https://remix.ethereum.org/>`_ מספק callback כזה
שמאפשר ייבוא קבצים מכתובות URL של HTTP, IPFS ו-Swarm או הפניות ישירות לחבילות ברישום NPM
`<https://remix-ide.readthedocs.io/en/latest/import.html>`_.

לתיאור מלא של מערכת הקבצים הווירטואלית והלוגיקה של פתרון הנתיב המשמשת את
הקומפיילר ראה :ref:`רזולוציית נתיב <path-resolution>`.

.. index:: ! comment, natspec

הערות
========

אפשר להוסיף הערות בשורה אחת (``//``) והערות מרובות שורות (``/*...*/``).

.. code-block:: solidity

    // This is a single-line comment.

    /*
    This is a
    multi-line comment.
    */

.. note::
   הערה בשורה אחת מסתיימת על ידי כל מסיים  שורה ב-unicode
   (LF, VF, FF, CR, NEL, LS או PS) בקידוד UTF-8. המסיים הוא עדיין חלק
   מקוד המקור אחרי ההערה, לכן, אם הוא לא סימבול ASCII
   (אלה הם NEL, LS ו-PS), הוא יוביל לשגיאת פרסר.

בנוסף, יש סוג נוסף של הערות שנקרא הערת NatSpec,
אשר מפורט במדריך :ref:`style<style_guide_natspec>`. הם כתובים עם
קו-נטוי משולש (``///``) או בלוק כוכבית כפולה (``/** ... */``)
ויש להשתמש בהן ישירות מעל פקודות או הגדרת פונקציות.
